<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[java多线程]]></title>
    <url>%2F2019%2F01%2F15%2Fjava%E5%A4%9A%E7%BA%BF%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[等待池假设一个线程a 调用了某个对象的wait方法，线程a就会释放该锁，进入到该对象的等待池中。等待池中的线程不会参与锁的竞争。 锁池假设线程a已经拥有了某个对象的锁，而其他线程想要执行这个对象的某个同步代码块（syschronized）的代码,由于这些线程在进入对象的同步代码块（syschronized）之前必须先获得这个对象的锁，但是该对象的锁目前正被线程a拥有，所以这些线程就进入了该对象的锁池中。 wait wait 方法只能在同步代码块（syschronized）中调用，调用后就会释放该锁，进入到等待池中。（暂时失去锁机制 wait（long timeOut）到超时时间后还需要返还对象锁）； 进入wait 状态的线程能够被notify 和notiffyAll唤醒，然后从等待池进入锁池中参与锁的竞争 wait通常有条件的执行，直到某个条件为真（while） sleepsleep 使当前线程进入停滞状态（阻塞当前线程），让出cpu的使用，目的使不让线程独自霸占该进程的所获的所有cpu资源，留给其他线程执行的机会。 sleep 使Thread的静态方法，他不能改变对象的锁，所以当在一个同步代码块中调用sleep方法，虽然线程休眠了，但是对象的锁并没有被释放，其他线程不能访问这个对象的锁； 在sleep的休眠期满了之后，该线程不一点会立即执行，这是因为其他线程可能正在运行而且没有被调度为放弃执行，除非此线程有更高的优先级。 yieldyield 和sleep大部分一样， yield和sleep的主要区别是，yield会临时暂停当前正在执行的线程，来让有同样优先级的线程有机会执行，或则等待线程的优先级都比较低，那么该线程会继续执行。执行了yeild方法的线程，什么时候会继续运行由调度器来决定。 notifynotify 调用后 只会将等待池中的一个随机移到锁池，所以这个函数使用不当会造成死锁，当这个被移到锁池的线程获得锁之后没有唤醒其他线程（调用notigy，notifyAll）就会可能造成死锁。因为在等待池中的线程不会参与锁的竞争。 notifyAllnotifyAll 会将等待池中的全部线程移到锁池。 原子性Java的原子性就和数据库事务的原子性差不多，一个操作中要么全部执行成功或者失败。 JMM只是保证了基本的原子性，但类似于i++之类的操作，看似是原子操作，其实里面涉及到: 获取 i 的值。 自增。 再赋值给 i。 这三步操作，所以想要实现i++这样的原子操作就需要用到synchronized或者是lock进行加锁处理。 可见性由于CPU直接从主内存中读取数据的效率不高，所以都会对应的CPU高速缓存，先将主内存中的数据读取到缓存中，线程修改数据之后首先更新到缓存，之后才会更新到主内存。如果此时还没有将数据更新到主内存其他的线程此时来读取就是修改之前的数据。 volatile关键字就是用于保证内存可见性，当线程A更新了 volatile 修饰的变量时，它会立即刷新到主线程，并且将其余缓存中该变量的值清空，导致其余线程只能去主内存读取最新值。 使用volatile关键词修饰的变量每次读取都会得到最新的数据，不管哪个线程对这个变量的修改都会立即刷新到主内存。 synchronized和加锁也能能保证可见性，实现原理就是在释放锁之前其余线程是访问不到这个共享变量的。但是和volatile相比开销较大。 顺序性正常情况下的执行顺序应该是1&gt;&gt;2&gt;&gt;3。但是有时JVM为了提高整体的效率会进行指令重排导致执行的顺序可能是2&gt;&gt;1&gt;&gt;3。但是JVM也不能是什么都进行重排，是在保证最终结果和代码顺序执行结果一致的情况下才可能进行重排。 重排在单线程中不会出现问题，但在多线程中会出现数据不一致的问题。 Java 中可以使用volatile来保证顺序性，synchronized 和 lock也可以来保证有序性，和保证原子性的方式一样，通过同一段时间只能一个线程访问来实现的。 除了通过volatile关键字显式的保证顺序之外，JVM还通过happen-before原则来隐式的保证顺序性。 其中有一条就是适用于volatile关键字的，针对于volatile关键字的写操作肯定是在读操作之前，也就是说读取的值肯定是最新的。 123456789101112131415161718public class Singleton &#123; private static volatile Singleton singleton; private Singleton() &#123; &#125; public static Singleton getInstance() &#123; if (singleton == null) &#123; synchronized (Singleton.class) &#123; if (singleton == null) &#123; singleton = new Singleton(); &#125; &#125; &#125; return singleton; &#125; &#125; 这里的volatile关键字主要是为了防止指令重排。 如果不用volatile，singleton = new Singleton();，这段代码其实是分为三步： 分配内存空间。(1) 初始化对象。(2) 将singleton对象指向分配的内存地址。(3) 加上volatile是为了让以上的三步操作顺序执行，反之有可能第三步在第二步之前被执行就有可能导致某个线程拿到的单例对象还没有初始化，以致于使用报错。 volatilevolatile关键字只能保证可见性，顺序性，不能保证原子性。]]></content>
      <categories>
        <category>后台</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android ClassLoader]]></title>
    <url>%2F2019%2F01%2F14%2FAndroid%20ClassLoder%2F</url>
    <content type="text"><![CDATA[一个运行的Android应用至少有2个ClassLoader，一个是BootClassLoader(系统启动时创建的)，一个是PathClassLoader(应用启动时创建的，用于加载/data/data/packagename/apkname.apk) android中应用的类加载器主要有两种，分别是PathClassLoader和DexClassLoader，PathClassLoader只能用来加载已安装应用的dex文件，而DexClassLoader可以用来加载未安装的apk\jar等文件； PathClassLoder12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849/** * Provides a simple &#123;@link ClassLoader&#125; implementation that operates on a list * of files and directories in the local file system, but does not attempt to * load classes from the network. Android uses this class for its system class * loader and for its application class loader(s). */public class PathClassLoader extends BaseDexClassLoader &#123; /** * Creates a &#123;@code PathClassLoader&#125; that operates on a given list of files * and directories. This method is equivalent to calling * &#123;@link #PathClassLoader(String, String, ClassLoader)&#125; with a * &#123;@code null&#125; value for the second argument (see description there). * * @param dexPath the list of jar/apk files containing classes and * resources, delimited by &#123;@code File.pathSeparator&#125;, which * defaults to &#123;@code ":"&#125; on Android * @param parent the parent class loader */ public PathClassLoader(String dexPath, ClassLoader parent) &#123; super(dexPath, null, null, parent); &#125; /** * Creates a &#123;@code PathClassLoader&#125; that operates on two given * lists of files and directories. The entries of the first list * should be one of the following: * * &lt;ul&gt; * &lt;li&gt;JAR/ZIP/APK files, possibly containing a "classes.dex" file as * well as arbitrary resources. * &lt;li&gt;Raw ".dex" files (not inside a zip file). * &lt;/ul&gt; * * The entries of the second list should be directories containing * native library files. * * @param dexPath the list of jar/apk files containing classes and * resources, delimited by &#123;@code File.pathSeparator&#125;, which * defaults to &#123;@code ":"&#125; on Android * @param libraryPath the list of directories containing native * libraries, delimited by &#123;@code File.pathSeparator&#125;; may be * &#123;@code null&#125; * @param parent the parent class loader */ public PathClassLoader(String dexPath, String libraryPath, ClassLoader parent) &#123; super(dexPath, null, libraryPath, parent); &#125;&#125; PathClassLoader是ClassLoader的简单实现且只能加载本地的列表文件或目录，在Android中也就是已安装好的APK，它不能加载来自网络的类。Android中的系统类加载器与应用类加载器都是PathClassLoader。 PathClassLoader是ClassLoader的简单实现且只能加载本地的列表文件或目录，在Android中也就是已安装好的APK，它不能加载来自网络的类。Android中的系统类加载器与应用类加载器都是PathClassLoader。 Android系统使用PathClassLoader来加载系统类和应用程序的类，如果是加载非系统应用程序类，则会加载data/app/目录下的dex文件以及包含dex的apk文件或jar文件，不管是加载那种文件，最终都是要加载dex文件，在这里为了方便理解，我们将dex文件以及包含dex的apk文件或jar文件统称为dex相关文件。PathClassLoader不建议开发直接使用。PathClassLoader继承自BaseDexClassLoader，很明显PathClassLoader的方法实现都在BaseDexClassLoader中。从PathClassLoader的构造方法也可以看出它遵循了双亲委托模式。 dexPath：包含dex文件的JAR/ZIP/APK文件的路径 librarySearchPath：native library文件的路径 parent：父类加载器 DexClassLoader123456789101112131415161718192021222324252627282930313233343536373839/** * A class loader that loads classes from &#123;@code .jar&#125; and &#123;@code .apk&#125; files * containing a &#123;@code classes.dex&#125; entry. This can be used to execute code not * installed as part of an application. * * &lt;p&gt;This class loader requires an application-private, writable directory to * cache optimized classes. Use &#123;@code Context.getDir(String, int)&#125; to create * such a directory: &lt;pre&gt; &#123;@code * File dexOutputDir = context.getDir("dex", 0); * &#125;&lt;/pre&gt; * * &lt;p&gt;&lt;strong&gt;Do not cache optimized classes on external storage.&lt;/strong&gt; * External storage does not provide access controls necessary to protect your * application from code injection attacks. */public class DexClassLoader extends BaseDexClassLoader &#123; /** * Creates a &#123;@code DexClassLoader&#125; that finds interpreted and native * code. Interpreted classes are found in a set of DEX files contained * in Jar or APK files. * * &lt;p&gt;The path lists are separated using the character specified by the * &#123;@code path.separator&#125; system property, which defaults to &#123;@code :&#125;. * * @param dexPath the list of jar/apk files containing classes and * resources, delimited by &#123;@code File.pathSeparator&#125;, which * defaults to &#123;@code ":"&#125; on Android * @param optimizedDirectory directory where optimized dex files * should be written; must not be &#123;@code null&#125; * @param libraryPath the list of directories containing native * libraries, delimited by &#123;@code File.pathSeparator&#125;; may be * &#123;@code null&#125; * @param parent the parent class loader */ public DexClassLoader(String dexPath, String optimizedDirectory, String libraryPath, ClassLoader parent) &#123; super(dexPath, new File(optimizedDirectory), libraryPath, parent); &#125;&#125; DexClassLoader可以从包含dex文件的JAR或APK中来加载类，而这些代码源允许不必是安装应用的一部分，因此可用于动态加载。 构造方法中有一个新的参数为optimizedDirectory，它表示优化后的dex文件要写入的路径。通常建议使用如下路径： context.getCodeCacheDir(); 总结 PathClassLoader: 主要用于系统和app的类加载器,其中optimizedDirectory为null, 采用默认目录/data/dalvik-cache/ DexClassLoader: 可以从包含classes.dex的jar或者apk中，加载类的类加载器, 可用于执行动态加载,但必须是app私有可写目录来缓存odex文件. 能够加载系统没有安装的apk或者jar文件， 因此很多插件化方案都是采用DexClassLoader; BaseDexClassLoader: 比较基础的类加载器, PathClassLoader和DexClassLoader都只是在构造函数上对其简单封装而已.]]></content>
      <categories>
        <category>Android逆向</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>ClassLoader</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java classLoader]]></title>
    <url>%2F2019%2F01%2F04%2Fjava%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%2F</url>
    <content type="text"><![CDATA[在 Java 中，类的实例化流程分为两个部分：类的加载和类的实例化。类的加载又分为显式加载和隐式加载。大家使用 new 关键字创建类实例时，其实就隐式地包含了类的加载过程。对于类的显式加载来说，比较常用的是 Class.forName。其实，它们都是通过调用 ClassLoader 类的 loadClass 方法来完成类的实际加载工作的。 java类加载层次解构ClassLoader 在加载类时有一定的层次关系和规则。在 Java 中，有四种类型的类加载器，从上到下分别为：BootStrapClassLoader、ExtClassLoader、AppClassLoader 以及用户自定义的 ClassLoader。这四种类加载器分别负责不同路径的类的加载，并形成了一个类加载的层次结构。 bootStrapClassLoaderBootstrap ClassLoader最顶层的加载类，主要加载核心类库，%JRE_HOME%\lib下的rt.jar、resources.jar、charsets.jar和class等。可以通过 System.getProperty(“sun.boot.class.path”)获得相应路径。 可以通过启动jvm时指定-Xbootclasspath和路径来改变Bootstrap ClassLoader的加载目录。比如java -Xbootclasspath/a:path被指定的文件追加到默认的bootstrap路径中。 ExtClassLoader扩展的类加载器，加载目录%JRE_HOME%\lib\ext目录下的jar包和class文件。还可以加载-D java.ext.dirs选项指定的目录。可以通过System.out.println(System.getProperty(“java.ext.dirs”));相应路径 AppClassLoaderAppclass Loader也称为SystemAppClass加载当前应用的classpath的所有类。 通过System.out.println(System.getProperty(“java.class.path”));获得相应路径 双亲委托 一个类加载器加载class时，是通过“委托模式”进行的，它首先判断这个class是不是已经加载成功，如果没有的话它并不是自己进行查找，而是先通过父加载器，然后递归下去，直到Bootstrap ClassLoader，如果Bootstrap classloader找到了，直接返回，如果没有找到，则一级一级返回，最后到达自身去查找这些对象。这种机制就叫做双亲委托。 重要方法findLoadedClass每个类加载器都维护有自己的一份已加载类名字空间，其中不能出现两个同名的类。凡是通过该类加载器加载的类，无论是直接的还是间接的，都保存在自己的名字空间中，该方法就是在该名字空间中寻找指定的类是否已存在，如果存在就返回给类的引用，否则就返回 null。这里的直接是指，存在于该类加载器的加载路径上并由该加载器完成加载，间接是指，由该类加载器把类的加载工作委托给其他类加载器完成类的实际加载。 getSystemClassLoader该方法返回系统使用的 ClassLoader。可以在自己定制的类加载器中通过该方法把一部分工作转交给系统类加载器去处理。 defineClass该方法是 ClassLoader 中非常重要的一个方法，它接收以字节数组表示的类字节码，并把它转换成 Class 实例，该方法转换一个类的同时，会先要求装载该类的父类以及实现的接口类。 findClass从指定的路径中查找.class文件，并加载类 loadClass加载类的入口方法，调用该方法完成类的显式加载。通过对该方法的重新实现，我们可以完全控制和管理类的加载过程。]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[springboot及bean 初始化运行]]></title>
    <url>%2F2018%2F12%2F18%2Fspringboot%E5%8F%8Abean%20%E5%88%9D%E5%A7%8B%E5%8C%96%E8%BF%90%E8%A1%8C%2F</url>
    <content type="text"><![CDATA[spring boot 启动时运行Spring Boot应用程序在启动后，会遍历CommandLineRunner接口的实例并运行它们的run方法。也可以利用@Order注解（或者实现Order接口）来规定所有CommandLineRunner实例的运行顺序。 12345678910111213@Order(10)@Componentpublic class ContractUsegeStatusInitRunner implements CommandLineRunner &#123; private static Logger logger= LoggerFactory.getLogger(ContractUsegeStatusInitRunner.class); @Autowired private ScheduleService scheduleService; @Override public void run(String... strings) throws Exception &#123; logger.info("&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;启动时合同使用状态更新"); scheduleService.updateContractUsegeStatus(); logger.info("&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;合同使用状态更新结束"); &#125; Bean 初始化完成时运行执行顺序 Constructor &gt; @PostConstruct &gt; InitializingBean &gt; init-method &lt;beanclass=”InitSequenceBean”init-method=”initMethod”&gt; 123456789101112131415161718192021public class InitSequenceBean implements InitializingBean &#123; public InitSequenceBean() &#123; System.out.println("InitSequenceBean: constructor"); &#125; @PostConstruct public void postConstruct() &#123; System.out.println("InitSequenceBean: postConstruct"); &#125; public void initMethod() &#123; System.out.println("InitSequenceBean: init-method"); &#125; @Override public void afterPropertiesSet() throws Exception &#123; System.out.println("InitSequenceBean: afterPropertiesSet"); &#125;&#125; Bean销毁之后执行使用@PreDestroy]]></content>
      <tags>
        <tag>Springboot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[springboot多个数据库配置]]></title>
    <url>%2F2018%2F11%2F29%2Fspringboot%E5%A4%9A%E4%B8%AA%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[多个redis数据库多个redis配置的基类123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137package com.icekredit.config;import com.fasterxml.jackson.annotation.JsonAutoDetect;import com.fasterxml.jackson.annotation.PropertyAccessor;import com.fasterxml.jackson.databind.ObjectMapper;import org.springframework.beans.factory.annotation.Value;import org.springframework.cache.CacheManager;import org.springframework.cache.annotation.EnableCaching;import org.springframework.cache.interceptor.KeyGenerator;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import org.springframework.data.redis.cache.RedisCacheManager;import org.springframework.data.redis.connection.jedis.JedisConnectionFactory;import org.springframework.data.redis.core.RedisTemplate;import org.springframework.data.redis.serializer.Jackson2JsonRedisSerializer;import org.springframework.data.redis.serializer.StringRedisSerializer;import redis.clients.jedis.JedisPoolConfig;import java.lang.reflect.Method;/** * spring-boot-data-packing 设置Redis多实例的基类 * * @Author jianganwei * @Date 2018/8/13 */@EnableCaching@Configurationpublic class RedisConfig &#123; @Value("$&#123;spring.redis.pool.max-active&#125;") private int redisPoolMaxActive; @Value("$&#123;spring.redis.pool.max-wait&#125;") private int redisPoolMaxWait; @Value("$&#123;spring.redis.pool.max-idle&#125;") private int redisPoolMaxIdle; @Value("$&#123;spring.redis.pool.min-idle&#125;") private int redisPoolMinIdle; /** * 配置Key的生成方式 * * @return */ @Bean public KeyGenerator keyGenerator() &#123; return new KeyGenerator() &#123; @Override public Object generate(Object o, Method method, Object... objects) &#123; StringBuilder stringBuilder = new StringBuilder(); stringBuilder.append(o.getClass().getName()) .append(method.getName()); for (Object object : objects) &#123; stringBuilder.append(object.toString()); &#125; return stringBuilder.toString(); &#125; &#125;; &#125; /** * 创建redis连接工厂 * * @param dbIndex * @param host * @param port * @param password * @param timeout * @return */ public JedisConnectionFactory createJedisConnectionFactory(int dbIndex, String host, int port, String password, int timeout) &#123; JedisConnectionFactory jedisConnectionFactory = new JedisConnectionFactory(); jedisConnectionFactory.setDatabase(dbIndex); jedisConnectionFactory.setHostName(host); jedisConnectionFactory.setPort(port); jedisConnectionFactory.setPassword(password); jedisConnectionFactory.setTimeout(timeout); jedisConnectionFactory.setPoolConfig(setPoolConfig(redisPoolMaxIdle, redisPoolMinIdle, redisPoolMaxActive, redisPoolMaxWait, true)); return jedisConnectionFactory; &#125; /** * 设置连接池属性 * * @param maxIdle * @param minIdle * @param maxActive * @param maxWait * @param testOnBorrow * @return */ public JedisPoolConfig setPoolConfig(int maxIdle, int minIdle, int maxActive, int maxWait, boolean testOnBorrow) &#123; JedisPoolConfig poolConfig = new JedisPoolConfig(); poolConfig.setMaxIdle(maxIdle); poolConfig.setMinIdle(minIdle); poolConfig.setMaxTotal(maxActive); poolConfig.setMaxWaitMillis(maxWait); poolConfig.setTestOnBorrow(testOnBorrow); return poolConfig; &#125; /** * 设置RedisTemplate的序列化方式 * * @param redisTemplate */ public void setSerializer(RedisTemplate&lt;Object,Object&gt; redisTemplate) &#123; Jackson2JsonRedisSerializer jackson2JsonRedisSerializer = new Jackson2JsonRedisSerializer(Object.class); ObjectMapper om = new ObjectMapper(); om.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY); om.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL); jackson2JsonRedisSerializer.setObjectMapper(om); redisTemplate.setValueSerializer(jackson2JsonRedisSerializer); redisTemplate.setHashKeySerializer(jackson2JsonRedisSerializer); redisTemplate.setKeySerializer(new StringRedisSerializer()); redisTemplate.afterPropertiesSet(); &#125; /** * 设置RedisTemplate的序列化方式 * * @param redisTemplate */ public void setSerializerNomal(RedisTemplate redisTemplate) &#123; Jackson2JsonRedisSerializer jackson2JsonRedisSerializer = new Jackson2JsonRedisSerializer(Object.class); ObjectMapper om = new ObjectMapper(); om.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY); om.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL); jackson2JsonRedisSerializer.setObjectMapper(om); //设置键（key）的序列化方式 redisTemplate.setKeySerializer(new StringRedisSerializer()); //设置值（value）的序列化方式 redisTemplate.setValueSerializer(jackson2JsonRedisSerializer); redisTemplate.afterPropertiesSet(); &#125;&#125; redis数据库配置redis数据库的配置，第二个第三个类似 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869package com.icekredit.config;import org.springframework.beans.factory.annotation.Value;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import org.springframework.context.annotation.Primary;import org.springframework.data.redis.connection.RedisConnectionFactory;import org.springframework.data.redis.core.RedisTemplate;import org.springframework.data.redis.core.StringRedisTemplate;/** * @program: Bemoan * @description: * @author: jianganwei * @create: 2018-11-28 17:19 **/@Configurationpublic class BemoanRedisConfig extends RedisConfig &#123; @Value("$&#123;spring.redis.bemoan.database&#125;") private int dbIndex; @Value("$&#123;spring.redis.bemoan.host&#125;") private String host; @Value("$&#123;spring.redis.bemoan.port&#125;") private int port; @Value("$&#123;spring.redis.bemoan.timeout&#125;") private String password; @Value("$&#123;spring.redis.bemoan.timeout&#125;") private int timeout; /** * 配置redis连接工厂 * * @return */ @Primary @Bean public RedisConnectionFactory cacheRedisConnectionFactory() &#123; return createJedisConnectionFactory(dbIndex, host, port, password, timeout); &#125; /** * 配置redisTemplate 注入方式使用@Resource(name="") 方式注入 * * @return */ @Bean(name = "bemoanRedis") public RedisTemplate&lt;Object,Object&gt; bemoanRedis() &#123; RedisTemplate&lt;Object,Object&gt; template = new RedisTemplate&lt;Object,Object&gt;(); template.setConnectionFactory(cacheRedisConnectionFactory()); setSerializer(template); template.afterPropertiesSet(); return template; &#125; /** * 配置redisTemplate 注入方式使用@Resource(name="") 方式注入 * * @return */ @Bean(name = "bemoanStringRedis") public StringRedisTemplate stringRedisTemplate() &#123; StringRedisTemplate template = new StringRedisTemplate(); template.setConnectionFactory(cacheRedisConnectionFactory()); setSerializerNomal(template); template.afterPropertiesSet(); return template; &#125;&#125; 多个mysql数据库配置配置类12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152package com.icekredit.config;import org.apache.ibatis.session.SqlSessionFactory;import org.mybatis.spring.SqlSessionFactoryBean;import org.mybatis.spring.SqlSessionTemplate;import org.springframework.beans.factory.annotation.Qualifier;import org.springframework.boot.autoconfigure.jdbc.DataSourceBuilder;import org.springframework.boot.context.properties.ConfigurationProperties;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import org.springframework.jdbc.datasource.DataSourceTransactionManager;import tk.mybatis.spring.annotation.MapperScan;import javax.sql.DataSource;/** * @program: Bemoan * @description: 个人数据库配置 * @author: jianganwei * @create: 2018-11-29 09:43 **/@Configuration@MapperScan(basePackages = "com.icekredit.mapper.person",sqlSessionFactoryRef = "personSqlSessionFactory")public class PersonDataSourceConfig &#123; @Bean("personDataSource") @ConfigurationProperties(prefix = "spring.datasource.person") public DataSource personDataSource()&#123; return DataSourceBuilder.create().build(); &#125; @Bean("personSqlSessionFactory") public SqlSessionFactory personSqlSessionFactory(@Qualifier("personDataSource") DataSource dataSource) throws Exception&#123; SqlSessionFactoryBean factoryBean=new SqlSessionFactoryBean(); org.apache.ibatis.session.Configuration configuration=new org.apache.ibatis.session.Configuration(); configuration.setUseGeneratedKeys(true); factoryBean.setDataSource(dataSource); PathMatchingResourcePatternResolver resolver = new PathMatchingResourcePatternResolver(); factoryBean.setMapperLocations(resolver.getResources("classpath:/xml/*.xml")); configuration.setMapUnderscoreToCamelCase(true); factoryBean.setFailFast(true); return factoryBean.getObject(); &#125; @Bean("personTransactionManager") public DataSourceTransactionManager personTransactionManager(@Qualifier("personDataSource") DataSource dataSource)&#123; DataSourceTransactionManager manager=new DataSourceTransactionManager(); manager.setDataSource(dataSource); return manager; &#125; @Bean public SqlSessionTemplate personSqlTemplate(@Qualifier("personDataSource") DataSource dataSource)throws Exception&#123; return new SqlSessionTemplate(personSqlSessionFactory(dataSource)); &#125;&#125; 配置文件12345678910111213141516spring.datasource.person.driver-class-name: com.mysql.jdbc.Driverspring.datasource.person.url: jdbc:mysql://.mysql.rds.aliyuncs.com/icekredit_spring.datasource.person.username: jianganweispring.datasource.person.password: J_anwei_2017spring.datasource.person.type: com.alibaba.druid.pool.DruidDataSourcespring.datasource.person.initialSize: 5spring.datasource.person.minIdle: 5spring.datasource.person.maxIdle: 100spring.datasource.person.maxActive: 200spring.datasource.person.maxWait: 5000spring.datasource.person.testOnBorrow: falsespring.datasource.person.validationQuery: SELECT 1spring.datasource.person.testWhileIdle: truespring.datasource.person.timeBetweenEvictionRunsMillis: 30000spring.datasource.person.minEvictableIdleTimeMillis: 1800000spring.datasource.person.numTestsPerEvictionRun: 100]]></content>
      <tags>
        <tag>Springboot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java jni demo]]></title>
    <url>%2F2018%2F11%2F28%2Fjava%20jni%20demo%2F</url>
    <content type="text"><![CDATA[简介JNI是Java Native Interface的英文缩写, 中文翻译为本地调用, 自从Java 1.1开始就成为了Java标准的一部分. C/C++是系统级的编程语言, 可以用来开发任何和系统相关的程序和类库, 但是Java本身编写底层的应用比较难实现, 使用JNI可以调用现有的本地库, 极大地灵活了Java的开发. C/C++的效率是目前最好的语言, 可以使用C/C++来实现一些实时性非常高的部分. C/C++和Java本身都是非常流行的编程语言, 一些大型软件中经常使用语言之间的混合编程 新建一个HelloJNI类123456789101112131415161718192021package com.icekredit.demo;/** * @program: Bemoan * @description: JNI * @author: jianganwei * @create: 2018-11-26 14:46 **/public class HelloJNI &#123; static&#123; System.out.println(System.getProperty("java.library.path")); System.loadLibrary("HelloJNI"); &#125; private native void sayHello(); public static void main(String[] args) &#123; new HelloJNI().sayHello(); &#125;&#125; 代码的静态代码块在这个类被类加载器加载的时候调用了System.loadLibrary()方法来加载一个native库“HelloJNI”（这个库中实现了sayHello函数）。这个库在windows品台上对应了“helloJNI.dll”，而在类UNIX平台上对应了“libhelloJNI.so”。这个库应该包含在Java的库路径（使用java.library.path系统变量表示）上，否则这个上面的程序会抛出UnsatisfiedLinkError错误。你应该使用VM的参数-Djava.library.path=path_to_lib来指定包含native库的路径。接下来，我们使用native关键字将sayHello()方法声明为本地实例方法，这就很明显地告诉JVM：这个方法实现在另外一个语言中（C/C++），请去那里寻找他的实现。注意，一个native方法不包含方法体，只有声明。上面代码中的main方法实例化了一个HelloJJNI类的实例，然后调用了本地方法sayHello()。 编译得到.class文件javac HelloJNI.java 获得build一下项目.class 文件 就在target/classes中 链接生成头文件1javah -classpath target/classes -d ./jni com.icekredit.demo.HelloJNI 会在./jni 这个目录下生成 jni/com_icekredit_demo_HelloJNI.h 文件内容如下 1234567891011121314151617181920#include &lt;jni.h&gt;/* Header for class com_icekredit_demo_HelloJNI */#ifndef _Included_com_icekredit_demo_HelloJNI#define _Included_com_icekredit_demo_HelloJNI#ifdef __cplusplusextern "C" &#123;#endif/* * Class: com_icekredit_demo_HelloJNI * Method: sayHello * Signature: ()V */JNIEXPORT void JNICALL Java_com_icekredit_demo_HelloJNI_sayHello (JNIEnv *, jobject);#ifdef __cplusplus&#125;#endif#endif 在idea中配置一键生成头文件 编写c或c++代码c为.c c++为cpp文件新建文件.c或.cpp文件，实现上一步头文件的接口 12345678#include&lt;jni.h&gt;#include &lt;stdio.h&gt;#include "com_icekredit_demo_HelloJNI.h"JNIEXPORT void JNICALL Java_com_icekredit_demo_HelloJNI_sayHello(JNIEnv *env, jobject thisObj)&#123;printf("hello world!\n");return;&#125; 生成.o12gcc -fPIC -c -I"/opt/jdk1.8/jdk1.8.0_151/include" -I"/opt/jdk1.8/jdk1.8.0_151/include/linux" jni/HelloJNI.c 上面是jdk的路径，window 下第2个路径有点不同进去jdk 目录看一下就好了 生成.so文件，win 为dll1gcc -shared HelloJNI.o -o libHello.so 最后把生成的so文件放到java.library.path把so 文件放到某个目录下，或者配置运行时环境 -Djava.library.path=/home/jianganwei/IdeaProjects/Bemoan/lib 到so文件所在目录 最后生成o 和so 文件可以合成一步 1gcc -fPIC -I"/opt/jdk1.8/jdk1.8.0_151/include" -I"/opt/jdk1.8/jdk1.8.0_151/include/linux" -shared -o ./lib/libHelloJNI.so jni/HelloJNI.c idea 配置一键生成]]></content>
      <categories>
        <category>后台</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[文件处理]]></title>
    <url>%2F2018%2F11%2F28%2F%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95%2F</url>
    <content type="text"><![CDATA[记录一下在文件处理里面遇到的问题 读excel大文件依赖添加 git地址 12345&lt;dependency&gt; &lt;groupId&gt;com.monitorjbl&lt;/groupId&gt; &lt;artifactId&gt;xlsx-streamer&lt;/artifactId&gt; &lt;version&gt;2.0.0&lt;/version&gt; &lt;/dependency&gt; 示例代码 1234567Workbook workbook = StreamingReader.builder().rowCacheSize(1).bufferSize(4096).open(in); Sheet sheet = workbook.getSheetAt(0); Row firstRow = sheet.rowIterator().next(); Iterator&lt;Cell&gt; iterator = firstRow.cellIterator(); while (iterator.hasNext()) &#123; cellList.add(iterator.next().getStringCellValue()); &#125; 对输入流进行压缩123456789101112131415161718192021222324252627 private InputStream getZipInputStream(InputStream inputStream, String fileName) &#123; byte[] buf = new byte[1024]; try &#123; //ZipOutputStream类：完成文件或文件夹的压缩// ZipOutputStream out = new ZipOutputStream(new FileOutputStream("/home/jianganwei/下载/demo_LOCAL.zip")); ByteArrayOutputStream byteArrayOutputStream=new ByteArrayOutputStream(); ZipOutputStream out = new ZipOutputStream(byteArrayOutputStream); int len; ZipEntry zipEntry = new ZipEntry(fileName);// zipEntry.setUnixMode(666); out.putNextEntry(zipEntry); while ((len = inputStream.read(buf)) &gt; 0) &#123; out.write(buf, 0, len); &#125; out.closeEntry(); inputStream.close(); out.close(); logger.info("压缩完成."+fileName); return new ByteArrayInputStream(byteArrayOutputStream.toByteArray()); &#125; catch (Exception e) &#123;// TODO Auto-generated catch block e.printStackTrace(); return null; &#125; &#125; 123456&lt;!-- https://mvnrepository.com/artifact/org.apache.ant/ant --&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.ant&lt;/groupId&gt; &lt;artifactId&gt;ant&lt;/artifactId&gt; &lt;version&gt;1.9.3&lt;/version&gt; &lt;/dependency&gt;]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[springboot整合activiti]]></title>
    <url>%2F2018%2F11%2F08%2Fspringboot%E6%95%B4%E5%90%88activiti%2F</url>
    <content type="text"><![CDATA[添加依赖12345&lt;dependency&gt; &lt;groupId&gt;org.activiti&lt;/groupId&gt; &lt;artifactId&gt;activiti-spring-boot-starter-basic&lt;/artifactId&gt; &lt;version&gt;5.22.0&lt;/version&gt; &lt;/dependency&gt; 配置123456789101112131415161718192021222324252627282930313233343536373839404142434445@Configurationpublic class ActivitiConfig &#123; @Bean(&quot;activityConfig&quot;) public SpringProcessEngineConfiguration getSpringProcessEngineConfiguration( @Qualifier(&quot;reconciliationdb&quot;) DataSource reconciliationdb, @Qualifier(&quot;reconciliationdbTransactionManager&quot;)DataSourceTransactionManager transactionManager)&#123; SpringProcessEngineConfiguration configuration = new SpringProcessEngineConfiguration(); configuration.setDataSource(reconciliationdb); configuration.setTransactionManager(transactionManager); configuration.setActivityFontName(&quot;宋体&quot;); configuration.setLabelFontName(&quot;宋体&quot;);// configuration.setDatabaseSchemaUpdate(ProcessEngineConfigurationImpl.DB_SCHEMA_UPDATE_CREATE) return configuration; &#125; @Bean(&quot;activityProcessEngine&quot;) public ProcessEngine getProcessEngineFactoryBean(@Qualifier(&quot;activityConfig&quot;) SpringProcessEngineConfiguration configuration) throws Exception &#123; ProcessEngineFactoryBean factoryBean = new ProcessEngineFactoryBean(); factoryBean.setProcessEngineConfiguration(configuration); return factoryBean.getObject(); &#125; @Bean public RuntimeService getRuntimeService(@Qualifier(&quot;activityProcessEngine&quot;) ProcessEngine engine) &#123; return engine.getRuntimeService(); &#125; @Bean public RepositoryService getRepositoryService(@Qualifier(&quot;activityProcessEngine&quot;) ProcessEngine engine) &#123; return engine.getRepositoryService(); &#125; @Bean public TaskService getTaskService(@Qualifier(&quot;activityProcessEngine&quot;) ProcessEngine engine) &#123; return engine.getTaskService(); &#125; @Bean public HistoryService getHistoryService (@Qualifier(&quot;activityProcessEngine&quot;) ProcessEngine engine) &#123; return engine.getHistoryService(); &#125;&#125; 官方文档]]></content>
      <tags>
        <tag>Springboot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[爬虫学习笔记]]></title>
    <url>%2F2018%2F10%2F24%2F%E7%88%AC%E8%99%AB%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[数据定位方法 源码文本搜索 chrome search工具 代理服务器拦截 使用dom断点 Js注入拦截 chrome 堆栈信息 chrome console 很强大]]></content>
      <tags>
        <tag>爬虫</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[springboot自动配置demo]]></title>
    <url>%2F2018%2F10%2F23%2FSpringboot%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AEdemo%2F</url>
    <content type="text"><![CDATA[先创建需要自动配置的类123456789101112package com.icekredit.autoconfigdemo.demo;import org.springframework.beans.factory.annotation.Value;public class AutoconfigDemo &#123; @Value(&quot;$&#123;init.message&#125;&quot;) private String message; public void sout() &#123; System.out.println(&quot;the message is: &quot; + message); &#125;&#125; 编写创建该类的条件12345678910111213141516import org.springframework.boot.autoconfigure.condition.ConditionalOnMissingBean;import org.springframework.boot.autoconfigure.condition.ConditionalOnProperty;import org.springframework.boot.context.properties.ConfigurationProperties;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;@Configurationpublic class Demo &#123; @Bean @ConditionalOnMissingBean(AutoconfigDemo.class) @ConfigurationProperties(prefix = &quot;init&quot;) @ConditionalOnProperty(prefix = &quot;init&quot;,value = &quot;message&quot;) public AutoconfigDemo getDemo()&#123; return new AutoconfigDemo(); &#125;&#125; 最后在resources 目录下创建 META-INF/spring.factories在文件中配入需要自动创建的bean 条件类 1org.springframework.boot.autoconfigure.EnableAutoConfiguration=com.icekredit.autoconfigdemo.demo.Demo]]></content>
      <tags>
        <tag>Springboot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mqsql学习笔记]]></title>
    <url>%2F2018%2F10%2F10%2Fmysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[btree索引与hash索引的区别hash索引的优点hash索引解构的特殊性，其检索效率非常高，btree索引需要充根节点访问到分支节点，这样会有多次的io访问，所以hash索引 的查询效率远高于btree btree索引的优点1.hash索引不能满足范围查询而btree可以这是由于 Hash 索引比较的是进行 Hash 运算之后的 Hash 值，所以它只能用于 等值的过滤，不能用于基于范围的过滤，因为经过相应的 Hash 算法处理之后的 Hash 值的大小关系，并不能保证和Hash运算 前完全一样。 2.Hash 索引无法被用来避免数据的排序操作。由于 Hash 索引中存放的是经过 Hash 计算之后的 Hash 值，而且Hash值的 大小关系并不一定和 Hash 运算前的键值完全一样，所以数据库无法利用索引的数据来避免任何排序运算； 3.Hash 索引不能利用部分索引键查询。对于组合索引，Hash 索引在计算 Hash 值的时候是组合索引键合并后再一起计算Hash 值，而不是单独计算 Hash 值，所以通过组合索引的前面一个或几个索引键进行查询的时候，Hash 索引也无法被利用。 4.Hash 索引在任何时候都不能避免表扫描。Hash 索引是将索引键通过 Hash 运算之后，将 Hash运算结果的 Hash 值和所对 应的行指针信息存放于一个 Hash 表中，由于不同索引键存在相同 Hash 值，所以即使取满足某个 Hash 键值的数据的记录 条数，也无法从 Hash 索引中直接完成查询，还是要通过访问表中的实际数据进行相应的比较，并得到相应的结果。 注意事项{:.warning} 左连接求和时右边的表相关的列求和可能会重复。]]></content>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[quartz定时任务SpringBoot配置]]></title>
    <url>%2F2018%2F09%2F26%2Fquartz%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1SpringBoot%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[Quartz是Java领域最著名的开源任务调度工具。Quartz提供了极为广泛的特性如持久化任务，集群和分布式任务官方文档 http://www.quartz-scheduler.org/documentation/quartz-2.1.x/quick-start.html 添加maven依赖1234567891011121314151617181920&lt;dependency&gt; &lt;groupId&gt;org.quartz-scheduler&lt;/groupId&gt; &lt;artifactId&gt;quartz&lt;/artifactId&gt; &lt;version&gt;2.2.1&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.quartz-scheduler&lt;/groupId&gt; &lt;artifactId&gt;quartz-jobs&lt;/artifactId&gt; &lt;version&gt;2.2.1&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context-support&lt;/artifactId&gt; &lt;version&gt;4.3.13.RELEASE&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-tx&lt;/artifactId&gt; &lt;version&gt;4.3.13.RELEASE&lt;/version&gt;&lt;/dependency&gt; 解决Job 中bean 无法注入的问题1.建一个JobFactory然后 把其设置为 SchedulerFactoryBean 的 JobFactory。其目的是因为我在具体的Job 中 需要Spring 注入一些Service。所以我们要自定义一个jobfactory， 让其在具体job 类实例化时 使用Spring 的API 来进行依赖注入。 123456789101112131415161718192021import org.quartz.spi.TriggerFiredBundle;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.beans.factory.config.AutowireCapableBeanFactory;import org.springframework.context.annotation.Configuration;import org.springframework.scheduling.quartz.AdaptableJobFactory;import org.springframework.stereotype.Component;@Configuration@Componentpublic class JobFactory extends AdaptableJobFactory &#123; @Autowired private AutowireCapableBeanFactory capableBeanFactory; @Override protected Object createJobInstance(TriggerFiredBundle bundle) throws Exception &#123; //调用父类的方法 Object jobInstance = super.createJobInstance(bundle); //进行注入 capableBeanFactory.autowireBean(jobInstance); return jobInstance; &#125;&#125; 2.新建一个配置类把 SchedulerFactoryBean 设置为自定义的 JobFactory 并用它产生 Scheduler 12345678910111213@Autowiredprivate JobFactory jobFactory;@Bean(name="schedulerFactoryBean")public SchedulerFactoryBean getSchedulerFactoryBean() &#123; SchedulerFactoryBean factoryBean = new SchedulerFactoryBean(); factoryBean.setJobFactory(jobFactory); //factoryBean.setDataSource(datasource); return factoryBean;&#125;@Beanpublic Scheduler scheduler()&#123; return getSchedulerFactoryBean().getScheduler(); Quartz管理器123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260package com.icekredit.sfss.manager.impl;import com.icekredit.sfss.exception.BusinessException;import org.apache.commons.lang3.StringUtils;import org.quartz.*;import org.quartz.impl.matchers.GroupMatcher;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import org.springframework.stereotype.Component;import java.time.LocalDateTime;import java.util.*;/** * * Quartz管理器 * @author 李晋科(Jinke Li) * @version QuartzManager.java, 2018年6月12日 上午00:59:49 李晋科(Jinke Li) */@Componentpublic class QuartzManager &#123; private final static Logger LOGGER = LoggerFactory.getLogger(QuartzManager.class); private static Scheduler scheduler; private final static String JOB_GROUP_NAME = "OMS_JOBGROUP_NAME"; private final static String TRIGGER_GROUP_NAME = "OMS_TRIGGERGROUP_NAME"; private final static String TRIGGER_REDO_GROUP_NAME = "OMS_TRIGGERREDOGROUP_NAME"; /** * * job添加 * @param jobName * @param objJobClass * @param time */ public static void addJob(String jobName, Class&lt;? extends Job&gt; objJobClass, String time, Date startTime) &#123; addJob(jobName,objJobClass,time,startTime,null); &#125; /** * * job添加 * @param jobName * @param objJobClass * @param startTime * @param datas * @return */ public static Date addJob(String jobName, Class&lt;? extends Job&gt; objJobClass, String cronExp, Date startTime, Map&lt;String, Object&gt; datas) &#123; Date runTime = null; try &#123; JobDetail jobDetail = JobBuilder.newJob(objJobClass).withIdentity(jobName, JOB_GROUP_NAME).build(); if(datas != null) &#123; jobDetail.getJobDataMap().putAll(datas); &#125; TriggerBuilder&lt;Trigger&gt; builder = TriggerBuilder.newTrigger() .withIdentity(jobName, TRIGGER_GROUP_NAME); if (startTime.getTime() &gt; System.currentTimeMillis()) &#123; builder.startAt(startTime); &#125; if (StringUtils.isNotBlank(cronExp)) &#123; builder.withSchedule(CronScheduleBuilder.cronSchedule(cronExp)); &#125; if (StringUtils.isBlank(cronExp)) &#123; builder.withSchedule(SimpleScheduleBuilder.simpleSchedule()); &#125; Trigger trigger = builder.build(); runTime = scheduler.scheduleJob(jobDetail, trigger); if (scheduler.isShutdown())&#123; scheduler.start(); &#125; &#125; catch (Exception e) &#123; LOGGER.error("添加job出错",e); &#125; return runTime; &#125; /** * * job重试调度 * @param jobName * @param objJobClass * @param startTime * @param interval * @param repeatTimes * @param datas * @return */ public static Date addRedoJob(String jobName, Class&lt;? extends Job&gt; objJobClass, Date startTime, int interval, int repeatTimes, Map&lt;String, Object&gt; datas)&#123; Date runTime = null; JobDetail jobDetail = null; try &#123; JobKey jobKey = new JobKey(jobName, JOB_GROUP_NAME); if(scheduler.checkExists(jobKey)) &#123; jobDetail = scheduler.getJobDetail(jobKey); &#125; if(jobDetail == null) &#123; jobDetail = JobBuilder.newJob(objJobClass).withIdentity(jobKey).build(); if(datas != null) &#123; jobDetail.getJobDataMap().putAll(datas); &#125; &#125; SimpleTrigger trigger = TriggerBuilder.newTrigger() .withIdentity(jobName+"_redo_"+LocalDateTime.now(), TRIGGER_REDO_GROUP_NAME) .forJob(jobDetail) .withSchedule(SimpleScheduleBuilder.simpleSchedule().withIntervalInMinutes(interval).withRepeatCount(repeatTimes)) .startAt(startTime) .build(); runTime = scheduler.scheduleJob(trigger); &#125; catch (SchedulerException e) &#123; LOGGER.error("job重试调度出错",e);// throw new PcreditTaskEngineException("job重试调度出错",e); &#125; return runTime; &#125; /** * 移除所有重试任务 * 有重试任务移除返回true 无返回false * @param jobKey */ public static boolean unScheduleRedo(JobKey jobKey) &#123; try &#123; List&lt;? extends Trigger&gt; list = scheduler.getTriggersOfJob(jobKey); if (null != list) &#123; for(Trigger trigger: list) &#123; if(TRIGGER_REDO_GROUP_NAME.equals(trigger.getKey().getGroup())) &#123; scheduler.unscheduleJob(trigger.getKey()); return true; &#125; &#125; &#125; &#125; catch (SchedulerException e) &#123; LOGGER.error("取消重任务失败 jobName&#123;&#125;",jobKey,e); &#125; return false; &#125; /** * 取消任务计划(仅) * @param triggerKey */ public static void unScheduleJob(TriggerKey triggerKey) &#123; try &#123; scheduler.unscheduleJob(triggerKey); &#125; catch (SchedulerException e) &#123; LOGGER.error("取消任务失败 triggerName&#123;&#125;",triggerKey.getName(),e); &#125; &#125; /** * * job移除 * @param jobName */ public static void removeJob(String jobName) &#123; try &#123; scheduler.pauseTrigger(new TriggerKey(jobName, TRIGGER_GROUP_NAME)); scheduler.unscheduleJob(new TriggerKey(jobName, TRIGGER_GROUP_NAME)); scheduler.deleteJob(new JobKey(jobName, JOB_GROUP_NAME)); &#125; catch (Exception e) &#123; LOGGER.error("移除job抛错",e); &#125; &#125; /** * 删除所有任务 */ public static void removeAllJob() &#123; try &#123; GroupMatcher&lt;JobKey&gt; matcher = GroupMatcher.groupEquals(JOB_GROUP_NAME); Set&lt;JobKey&gt; jobkeySet = null; jobkeySet = scheduler.getJobKeys(matcher); List&lt;JobKey&gt; jobkeyList = new ArrayList&lt;JobKey&gt;(); jobkeyList.addAll(jobkeySet); scheduler.deleteJobs(jobkeyList); &#125; catch (SchedulerException e) &#123; e.printStackTrace(); &#125; &#125; /** * 检查任务存在 * * @param jobName * @return */ public static boolean checkJobExists(String jobName)&#123; try &#123; JobKey jobKey = new JobKey(jobName, JOB_GROUP_NAME); return scheduler.checkExists(jobKey); &#125; catch (Exception e) &#123; LOGGER.error("检查任务出错",e); throw new BusinessException("100000000","检查任务出错",1); &#125; &#125; /** * 开启调度 */ public static void startJobs() &#123; try &#123; scheduler.start(); &#125; catch (Exception e) &#123; LOGGER.error("启动调度出错",e); &#125; &#125; /** * 关闭调度-关闭后不能重启 */ public static void shutdownJobs() &#123; try &#123; if(!scheduler.isShutdown()) &#123; scheduler.shutdown(); &#125; &#125; catch (Exception e) &#123; LOGGER.error("关闭调度出错",e); &#125; &#125; /** * Getter method for &lt;tt&gt;scheduler&lt;/tt&gt;. * * @return value of scheduler */ public static Scheduler getScheduler() &#123; return scheduler; &#125; /** * Setter method for &lt;tt&gt;scheduler&lt;/tt&gt;. * * @param scheduler value to be assigned to scheduler */ public static void setScheduler(Scheduler scheduler) &#123; QuartzManager.scheduler = scheduler; &#125;&#125; 初始化123456789101112131415161718192021222324252627282930313233package com.icekredit.sfss.init;import com.icekredit.sfss.manager.impl.QuartzManager;import com.icekredit.sfss.schedule.AlarmTaskJob;import org.quartz.Scheduler;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.boot.CommandLineRunner;import org.springframework.core.annotation.Order;import org.springframework.stereotype.Component;import java.util.Date;/** * TODO * * @author 李晋科(Jinke Li) * @version TaskInitRunner.java, 2018/6/12 16:31 李晋科(Jinke Li) */@Component@Order(1)public class TaskInitRunner implements CommandLineRunner &#123; @Autowired private Scheduler scheduler; @Override public void run(String... args) throws Exception &#123; QuartzManager.setScheduler(scheduler); QuartzManager.removeAllJob(); &#125;&#125; 添加任务123456789101112131415161718192021222324252627282930package com.icekredit.sfss.schedule;import com.icekredit.sfss.manager.impl.QuartzManager;import org.springframework.boot.CommandLineRunner;import org.springframework.core.annotation.Order;import org.springframework.stereotype.Component;import java.util.Date;/** * * @program: SFSS * @description: 添加定时任务 * @author: jianganwei * @create: 2018-09-11 17:32 **/@Component@Order(3)public class TaskAddRunner implements CommandLineRunner &#123; @Override public void run(String... strings) throws Exception &#123; QuartzManager.addJob("oms_alarm" , AlarmTaskJob.class ,"0 30 11 * * ?",new Date()); QuartzManager.addJob("oms_invalid_contract" , InvalidContractJob.class ,"0 0 1 * * ?",new Date()); QuartzManager.addJob("oms_notice_marketing_file_upload" , NoticeMarketingFileUpLoadJob.class ,"0 */5 * * * ?",new Date()); QuartzManager.addJob("oms_contract_use_status",UpdateContractUsegeStatus.class,"0 */10 * * * ?",new Date()); QuartzManager.addJob("active_contracts_side_agreement",ActiveContractSideAgreementJob.class,"0 * */1 * * ?",new Date()); //todo 补充协议定时任务 &#125;&#125;]]></content>
      <tags>
        <tag>quartz</tag>
      </tags>
  </entry>
</search>
